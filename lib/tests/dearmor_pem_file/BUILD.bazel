"Tests for dearmor_gpg_file"

load("//lib:dearmor_pem_file.bzl", "dearmor_pem_file")
load("//lib:testing.bzl", "assert_contains")

dearmor_pem_file(
    name = "debian_bookworm_key",
    key = ":debian_bookworm_signing_key.gpg",
)

genrule(
    name = "debian_keystrings",
    srcs = [":debian_bookworm_key"],
    outs = ["debian_keystrings.txt"],
    cmd = "cat $(location :debian_bookworm_key) | strings > $@",
    toolchains = ["@coreutils_toolchains//:resolved_toolchain"],
)

assert_contains(
    name = "debian_bookworm_key_binary",
    actual = ":debian_keystrings.txt",
    expected = "Debian Stable Release Key",
)

dearmor_pem_file(
    name = "microsoft_packages_keystrings_asc",
    key = ":microsoft_packages.asc",
)

genrule(
    name = "microsoft_packages_keystrings",
    srcs = [":microsoft_packages_keystrings_asc"],
    outs = ["microsoft_packages_keystrings.txt"],
    cmd = "cat $(location :microsoft_packages_keystrings_asc) | strings > $@",
    toolchains = ["@coreutils_toolchains//:resolved_toolchain"],
)

assert_contains(
    name = "microsoft_packages_key_binary",
    actual = ":microsoft_packages_keystrings.txt",
    expected = "Microsoft (Release signing) <gpgsecurity@microsoft.com>",
)

dearmor_pem_file(
    name = "test_private_key",
    key = ":test_private_key.pem",
)

# We strip metadata from PEM keys before converting to DER. This data is not retained and should be stripped when comparing.
# Additionally, strip newlines so we are doing equal comparisons between generated and provided keys.
genrule(
    name = "pruned_public_key_metadata",
    srcs = [":test_public_key.pem"],
    outs = ["generated_public_key.pem"],
    cmd = "cat $(location :test_public_key.pem) | grep -v -e \".*: .*\" | tr -d '\n' > $@",
)

genrule(
    name = "private_key_reencode_pem",
    srcs = [
        ":test_private_key",
        ":pruned_public_key_metadata",
    ],
    outs = ["private_key_reencode_pem.txt"],
    cmd = "echo -n $$(diff <(openssl rsa -inform der -in $(location :test_private_key) -pubout -outform pem 2>/dev/null | tr -d '\n') <(cat $(location :pruned_public_key_metadata))) | wc -l > $@",
    toolchains = ["@coreutils_toolchains//:resolved_toolchain"],
)

# Take DER formatted output of dearmor_pem_file containing private key, use it to generate a public key.
# Make sure generated public key is identical to the test public key file contents. (Forward/Backward encoding)
assert_contains(
    name = "reencode_private_key_public_key_matches_existing",
    actual = ":private_key_reencode_pem.txt",
    expected = "0",
)

dearmor_pem_file(
    name = "test_public_key",
    key = ":test_public_key.pem",
)

genrule(
    name = "openssl_in_der_out_pem_public_key",
    srcs = [
        ":test_public_key",
    ],
    outs = ["generated_test_public_key.gpg"],
    cmd = "openssl rsa -pubin -in $(location :test_public_key) -inform der -outform pem -out $@ 2>/dev/null"
)

genrule(
    name = "public_key_reencode_pem",
    srcs = [
        ":pruned_public_key_metadata",
        ":test_public_key.pem",
    ],
    outs = ["public_key_reencode_pem.txt"],
    cmd = "echo $$(diff $(location :pruned_public_key_metadata) $(location :test_public_key.pem)) > $@",
)

# Take DER formatted output of dearmor_pem_file containing public key, diff it against provided PEM input file.
# Make sure generated output from DER format is identical to provided input. (Forward/Backward encoding)
[
    assert_contains(
        name = "reencode_public_key_lacks_%s_field" % ATTR.lower(),
        actual = ":public_key_reencode_pem.txt",
        expected = "> %s:" % ATTR,
    )
    for ATTR in ["Comment", "Distribution", "Version"]
]
